# -*- coding: utf-8 -*-
"""Blood Cell.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14cFHIWQXNtTqhyLfHbpN-BmT_EXu5P6y
"""

import os
import pandas as pd
import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as plt
import seaborn as sns
import cv2
from tensorflow.keras.models import load_model
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input
from sklearn.metrics import confusion_matrix, accuracy_score
from sklearn.metrics import classification_report
from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.image import ImageDataGenerator

from google.colab import drive
drive.mount('/content/drive')

import zipfile

extract_path = "/content/unzipped_data"

with zipfile.ZipFile("/content/drive/MyDrive/archive (1).zip", 'r') as zip_ref:
  zip_ref.extractall(extract_path)

print("Unzipped Successfully!")

# Define the directory path

data_dir = '/content/unzipped_data/dataset2-master/dataset2-master/images/TRAIN'

#Define the class Labels

class_labels = ['EOSINOPHIL', 'LYMPHOCYTE', 'MONOCYTE', 'NEUTROPHIL']

#Initialize lists to hold file paths and Labels

filepaths = []
labels = []

#Loop through each class directory and gather file paths and Labels
for label in class_labels:
  class_dir = os.path.join(data_dir, label)
  for file in os.listdir(class_dir):
    if file.endswith('.jpeg') or file.endswith('.png'):
      filepaths.append(os.path.join(class_dir, file))
      labels.append(label)

import os

# List the contents of the unzipped data directory to inspect its structure
print(os.listdir('/content/unzipped_data'))
print(os.listdir('/content/unzipped_data/dataset2-master'))
print(os.listdir('/content/unzipped_data/dataset2-master/dataset2-master'))
print(os.listdir('/content/unzipped_data/dataset2-master/dataset2-master/images'))
print(os.listdir('/content/unzipped_data/dataset2-master/dataset2-master/images/TRAIN'))

bloodCell_df = pd.DataFrame({
  'filepaths': filepaths,
  'labels': labels
})

bloodCell_df = bloodCell_df.sample(frac=1).reset_index(drop=True)

bloodCell_df.head()

from tensorflow.keras.preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(rescale=1./255)

train = train_datagen.flow_from_directory(
    data_dir, # Use the correct data_dir variable
    target_size=(224,224),
    batch_size=32,
    class_mode='categorical'
)

import matplotlib.pyplot as plt
import numpy as np
def show_knee_images(image_gen):
  test_dict = image_gen.class_indices
  classes = list(test_dict.keys())
  images, labels=next(image_gen)
  plt.figure(figsize=(20,20))
  length = len(labels)
  if length<25:
    r=length
  else:
    r=25
  for i in range(r):
    plt.subplot(5, 5, i+1)
    image=(images[i]+1)/2
    plt.imshow(image)
    index=np.argmax(labels[i])
    class_name=classes [index]
    plt.title(class_name, color="green", fontsize=16)
    plt.axis('off')
  plt.show()
show_knee_images(train)

train_images, test_images = train_test_split(bloodCell_df, test_size=0.3, random_state=42)
train_set, val_set = train_test_split(bloodCell_df, test_size=0.2, random_state=42)
print(train_set.shape)
print(test_images.shape)
print(val_set.shape)
print(train_images.shape)

image_gen = ImageDataGenerator(preprocessing_function= tf.keras.applications.mobilenet_v2.preprocess_input)
train = image_gen.flow_from_dataframe(dataframe=train_set,x_col="filepaths",y_col="labels",
                                    target_size=(244,244),
                                    color_mode='rgb',
                                    class_mode="categorical",
                                    batch_size=8,
                                    shuffle=False
                                  )

test = image_gen.flow_from_dataframe(dataframe=test_images,x_col="filepaths", y_col="labels",
                                     target_size=(244,244),
                                     color_mode='rgb',
                                     class_mode="categorical",
                                     batch_size=8,
                                     shuffle=False
                                    )

val = image_gen.flow_from_dataframe(dataframe=val_set,x_col="filepaths", y_col="labels",
                                    target_size=(244,244),
                                    color_mode= 'rgb',
                                    class_mode="categorical",
                                    batch_size=8,
                                    shuffle=False
                                   )

model = keras.models.Sequential([
  keras.layers.Conv2D(filters=128, kernel_size=(8, 8), strides=(3, 3), activation='relu', input_shape=(224, 224, 3)),
  keras.layers.BatchNormalization(),
  keras.layers.Conv2D(filters=256, kernel_size=(5, 5), strides=(1, 1), activation='relu', padding="same"),
  keras.layers.BatchNormalization(),
  keras.layers.MaxPool2D(pool_size=(3, 3)),
  keras.layers.Conv2D(filters=256, kernel_size=(3, 3), strides=(1, 1), activation='relu', padding="same"),
  keras.layers.BatchNormalization(),
  keras.layers.Conv2D(filters=256, kernel_size=(1, 1), strides=(1, 1), activation='relu', padding="same"), # Corrected padding typo 'sane' to 'same'
  keras.layers.BatchNormalization(),
  keras.layers.Conv2D(filters=256, kernel_size=(1, 1), strides=(1, 1), activation='relu', padding="same"), # Duplicate layer, assuming intended
  keras.layers.BatchNormalization(),
  keras.layers.Conv2D(filters=512, kernel_size=(3, 3), activation='relu', padding="same"),
  keras.layers.BatchNormalization(), keras.layers.MaxPool2D(pool_size=(2, 2)),
  keras.layers.Conv2D(filters=512, kernel_size=(3, 3), activation='relu', padding="same"), # Added '=' for activation
  keras.layers.BatchNormalization(),
  keras.layers.Conv2D(filters=512, kernel_size=(3, 3), activation='relu', padding="same"), # Corrected mangled line and padding typo 'see' to 'same'
  keras.layers.BatchNormalization(),
  keras.layers.MaxPool2D(pool_size=(2, 2)),
  keras.layers.Conv2D(filters=512, kernel_size=(3, 3), activation='relu', padding="same"),
  keras.layers.BatchNormalization(),
  keras.layers.MaxPool2D(pool_size=(2, 2)),
  keras.layers.Flatten(),
  keras.layers.Dense(1024, activation='relu'),
  keras.layers.Dropout(0.5), # Corrected 8.5 to 0.5
  keras.layers.Dense(1024, activation='relu'), # Added '=' for activation
  keras.layers.Dropout(0.5),
  keras.layers.Dense(4, activation='softmax') # Added '=' for activation
])

model.compile(
    optimizer=tf.optimizers.SGD(learning_rate=0.001),
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

model.summary()

history = model.fit(train, epochs=5, validation_data=val, verbose=1)

history1 = model.fit(train, epochs=1, validation_data=val, verbose=1)

pred = model.predict(test)
pred = np.argmax(pred, axis=1)
labels = (train.class_indices)
labels = dict((v,k) for k,v in labels.items())
pred2 = [ labels[k] for k in pred]

plt.plot(history.history['accuracy'] + history1.history['accuracy'])
plt.plot(history.history['val_accuracy'] + history1.history['val_accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

plt.plot(history.history['loss'] + history1.history['loss'])
plt.plot(history.history['val_loss'] + history1.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

from sklearn.metrics import confusion_matrix, accuracy_score, classification_report
y_test = test_images.labels # set y_test to the expected output
print(classification_report(y_test, pred2))
print("Accuracy of the Model: {:.1f}%".format(accuracy_score(y_test, pred2)*100))

import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix
class_labels = ['EOSINOPHIL', 'LYMPHOCYTE', 'MONOCYTE', 'NEUTROPHIL']
cm = confusion_matrix(y_test, pred2)
plt.figure(figsize=(10, 7))
sns.heatmap(cm, annot=True, fmt='g', cmap='Blues')
plt.xticks(ticks=[0.5, 1.5, 2.5, 3.5], labels=class_labels)
plt.yticks(ticks=[0.5, 1.5, 2.5, 3.5], labels=class_labels)
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

model.save("Blood Cell.h5")